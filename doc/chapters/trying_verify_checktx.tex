\chapter{Trying to Verify checkTransaction}
\label{chap:connecting}
This chapter describes the process we've made on trying to integrate Stainless in Bitcoin-S.
It shows the differences between the error reporting by the sbt plugin and the JAR.
Finally, during our work on Bitcoin-S we found a bug that we explain along its corresponding bug fix.

\section{Integration}
During this work, Stainless bumped the sbt plugin from version 0.13.17 to 1.2.8 and Scala from 2.11.12 to 2.12.8.
So this section might be out of date now.

Bitcoin-S-Core uses sbt 1.2.8 and Scala 2.12.8, while Stainless sbt plugin is on sbt 0.13.17 and Scala 2.11.12.

Sbt introduced new features in the 1.x releade used by Bitcoin-S.

For example, they introduced the new slash syntax.
\begin{lstlisting}
  lazy val root = (project in file("."))
    .settings(
      name := "hello",
      version in ThisBuild := "1.0.0"
    )
\end{lstlisting}
The version line written without slash becomes now one with slash.
The right and left parameter of in-operator reverse and instad of the in-operator is now a slash.
\begin{lstlisting}
  ThisBuild / version := "1.0.0",
\end{lstlisting}
This is just one example of many others.

The bigger problem is, due to the different Scala and sbt versions, the error message, after trying to go in a sbt shell.
\begin{lstlisting}
  [warn] There may be incompatibilities among your library dependencies; run 'evicted'
         to see detailed eviction warnings.
  [error] java.lang.NoClassDefFoundError: sbt/SourcePosition
  ...
  Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore?
\end{lstlisting}
Downgrading Bitcoin-S sbt version to 0.13.17 fixes the error but then it can not load some libraries only compiled for newer versions.
So this would take too much time to fix and changes the Bitcoin-S code unwantingly.

The next approach is to use stainless cli instead of sbt.
Running stainless on all source files does not work, because the dependencies are missing.
The parameter \emph{-classpath} can resolve it but the value of this parameter must be the paths to all the dependencies separated by a ':'.
Finally, \emph{core} depends on \emph{secp256k1jni}, another package of Bitcoin-S written in Java.
So this needs to be in the source files to.

The final command looks like this in \emph{core} folder of Bitcoin-S:
\begin{lstlisting}[language=bash]
  $ stainless
    -classpath ".:$(find ~/.ivy2/ -type f -name *.jar | tr '\n' ':')"
    $(find . -type f -name *.scala | tr '\n' ' ')
    $(find ../secp256k1jni -type f -name *.java | tr '\n' ' ')
\end{lstlisting}
The output was some Stainless error.
\begin{lstlisting}
  [Internal] Error: object scala.reflect.macros.internal.macroImpl in compiler mirror
             not found.. Trace:
  [Internal] - scala.reflect.internal.MissingRequirementError$.signal
             (MissingRequirementError.scala:17)
  ...
  [Internal] object scala.reflect.macros.internal.macroImpl in compiler mirror not found.
  [Internal] Please inform the authors of Inox about this message
\end{lstlisting}
After some discussion, we decided to go another way, because the errors may take too much time and it might lead to a next error.
Let's extract the code needed to verify a transaction mainly the class Transaction and ScriptInterpreter with many other classes their depending on.

After this extraction Stainless was successfully integrated with both, sbt and JAR.
This leads us to another finding as described in the next section.

\section{Error Reporting with sbt and JAR}
// TODO https://github.com/epfl-lara/stainless/issues/484?

\section{Bugfix}
After so much digging and trying to understand the checkTransaction code, we found a bug even without Stainless.

Here the relevant code of checkTransaction again:
\begin{lstlisting}[language=scala]
  val prevOutputTxIds = transaction.inputs.map(_.previousOutput.txId)
  val noDuplicateInputs = prevOutputTxIds.distinct.size == prevOutputTxIds.size
\end{lstlisting}
What happens, if a TransactionOutPoint (previousOutput) references the same Transaction ID (txId) another does?

According to the Bitcoin protocol this is possible.
A transaction can have multiple outputs that should be referenceable by the next transaction.
What should not be possible is a transaction referencing the same output twice.
This was a bug in Bitcoin Core known as CVE-2018â€“17144 which was patched on September 18 2018.

Here, Bitcoin-S did a bit too much and marked all transaction as invalid, if they referenced a transaction twice in the next transaction.
The fix is, to check on TransactionOutPoint instead of TransactionOutPoint.txId, because TransactionOutPoint contains the txId as well as the output index it references.
\begin{lstlisting}[language=scala]
  val prevOutputs = transaction.inputs.map(_.previousOutput)
  val noDuplicateInputs = prevOutputs.distinct.size == prevOutputs.size
\end{lstlisting}
Since TransactionOutPoint is a case class and Scala has a built in == for case classes there is no need to implement TransactionOutPoint.==.

This was fixed in pull request \mypound435 on GitHub at April 23 2019 by us along a unit test to prevent this bug from apperaing again in the future.
