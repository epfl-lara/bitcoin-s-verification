\chapter{Using Stainless // TODO remove this chapter}
\label{chap:using_stainless}

\section{Scala compatibility (Pure Scala, imperative features, dedicated BigInt, Generics...)}

To be verified the Scala code extended with Stainless annotations is passed to the framework as input.
The source code should be written in so called Pure Scala, a functional subset of Scala, so that Stainless can perform the verification.
Additionally, the framework supports some imperative features.
We will see some of these restrictions we have detected during this work in the next chapter.

\subsection{Functional Pure Scala}
The following functional elements are a part of Pure Scala:
\begin{itemize}
  \item \textbf{Algebraic Data Types:} abstract class, case class, case object. 
  The root of ADT is an abstract class, unless only one case class or case object is defined.
  An abstract class cannot define fields and constructor arguments. 
  Case class and case object can extend an abstract class.
  An example of the ADT definition:
  \begin{lstlisting}[language=Scala]
    abstract class MyList
    case object MyEmpty extends MyList
    case class MyCons(elem: BigInt, rest: MyList) extends MyList
  \end{lstlisting}
  \item \textbf{Objects} for grouping classes and functions.
  An example of object definition:
  \begin{lstlisting}[language=Scala]
    object Specs {
      def increment(a: BigInt): BigInt = {
        a + 1
      }
    case class Identifier(id: BigInt)
    }
  \end{lstlisting}
  \item \textbf{Booleans:} logical operators  \textit{\&\&}, \textit{||}, \textit{!}, relational operator \textit{==}, Stainless syntax for boolean implication \textit{==>}. 
  The short-circuit interpretation is used, when the second argument of a Boolean expression is evaluated only when needed.
  \item \textbf{Generics.} Only invariant type parameters are supported, what means if S is subtype of T then List[S] and List[T] do not have sub-typing relationship.
  Covariant and contravariant type parameters, such as List[+T] and List[-T], are not supported. 
  Furthermore, only simple hierarchies are allowed, when subclass must define the same type parameters in the same order as a parent class.
  An example using Generics:
  \begin{lstlisting}[language=Scala]
    object Test {
      abstract class List[T]
      case class Cons[T](hd: T, tl: List[T]) extends List[T]
      case class Nil[T]() extends List[T]
      def contains[T](l: List[T], el: T) = { ... }
    }
  \end{lstlisting}
  \item \textbf{Methods} can be defined in an abstract class and implemented or overridden in case classes. 
  The call of superclass methods with the keyword \textit{super} is allowed. 
  The method parameters can have default values. 
  An example of method definition in case of inheritance:
  \begin{lstlisting}[language=Scala]
    object Test {
      sealed abstract class Base {
        def double(x: BigInt): BigInt = x * 2
      }

      case class Override() extends Base {
        override def double(x: BigInt): BigInt = {
          super.double(x + 1) + 42
        }
      }
    }
  \end{lstlisting}
  \item \textbf{Pattern matching.} 
  Simple nested pattern matching, matching on type only, pattern guards and custom pattern matching with \textit{unapply} method are supported.
  \item \textbf{Values}. 
  Only immutable variables are allowed. Thus, they must be defined with the keyword \textit{val} (and not with \textit{var}).
  \item \textbf{Inner functions.}
  \item \textbf{Anonymous functions.}
  \item \textbf{Anonymous classes} with an explicit parent. 
  An anonymous class should have the same number of public members as its parent.
  An example of anonymous class implementation:
  \begin{lstlisting}[language=Scala]
    abstract class Foo {
      def bar: Int
    }
    
    def makeFoo(x: Int): Foo = new Foo {
      def bar: Int = x
    }
  \end{lstlisting}
  \item \textbf{Local classes}. 
  The creation of local classes within a function are allowed. \cite{Stainless:pure_scala}
  \item \textbf{Functional arrays} which use the operation that do not modify an array.
\end{itemize}


\subsection{Imperative features}

Stainless supports extensions to Pure Scala implemeting some imperative features.
They will be translated by Stainless into Pure Scala during a preprocessing phase.

The following imperative components are supported:

\begin{itemize}
  \item \textbf{Mutable variables} which can be declared with the keyword \textit{var}.
  Declaration of mutable variables is allowed only as a local variable within a function, or in a case classe constuctor, or in trait if a default value is not assigned.
  \item  \textbf{While loops}. 
  Because besides main calculations in a loop the state of a loop counter changes at every iteration as a side effect, this kind of programming component does not belong to the functional paradigm and cannot be handled by solvers.
  Thus, Stainless generates automatically a postcondition with the negation of the loop condition as an argument. 
  Moreover, to make it stronger, the automatically generated postcondition can be customised with the keyword \textit{invariant}.
  An example of while loop implementation:
  \begin{lstlisting}[language=Scala]
    var res = 0
    var i = 0
    (while(i < 10) {
      res = res + i
      i = i + 1
    }) invariant(i >= 0 && res >= i)
  \end{lstlisting}
  \item \textbf{Function \textit{old}} can be used in postconditions. 
  It allows to get value of a variable before the execution of the block.
  This feature is useful dealing with mutable objects.
  An example of using the function \textit{old}:
  \begin{lstlisting}[language=Scala]
    case class A(var x: Int)
    def inc(a: A): Unit = {
      a.x = a.x + 1
    } ensuring(_ => a.x == old(a).x + 1)
  \end{lstlisting}
  \item \textbf{Arrays.} Stainless extends functional arrays allowing the reassignment of arrays elements. \cite{Stainless:imperative}
\end{itemize}


\subsection{Stainless library}

Besides annotations and functions helping for verification  some core data types and operation on them is defined in the Stainless library.
The own implementation and dedicated mapping of data types allows Stainless to transform it correctly into mathematical expressions of SMT solvers.
Thus, the functionality of some data types can be restricted.

For example, BigInt implemented in Stainless has constructors only with a parameter of the type Int or String, while other types of a parameter is allowed in Scala.
Furthermore, Stainless defines its own collection List[T] with the standard and some additional functions because SMT solvers do not support it.
Moreover, the own Sets and Maps are used in Stainless. \cite{Stainless:library}