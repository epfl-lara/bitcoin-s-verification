\chapter{Using Stainless}
\label{chap:using_stainless}
This chapter describes the setup and integration process of Stainless in a new or already existing project.
It also shows the compatibility of Stainless with Scala as Stainless supports only a purely functional subset of Scala which they call \emph{Pure Scala}.

\section{Configuration}
There are two ways to integrate Stainless in a Scala project, the Scala build tool (sbt) plugin or a command line tool.
Both, when run, analyses the code passed and report warnings to the console about the given code.
Stainless requires and Scala recommends Java SE Development Kit 8.
Newer Java versions won't compile.

\subsection{sbt}
sbt for Scala is like gradle or maven for Java.
It can compile Scala code continuously or manual, manage dependencies with support for Maven-formatted repositories, mixing Scala and Java projects and much more.

A simple sbt project has the following structure:
\dirtree{%
  .1 ..
  .2 project.
  .3 build.properties.
  .3 plugins.sbt.
  .2 src.
  .3 main.
  .4 scala.
  .5 Main.scala.
  .2 build.sbt.
}
\emph{build.properties} specifies the sbt version used for this project.
If the version is not available locally, sbt will download it.

In \emph{plugins.sbt} new sbt plugins can be added.
A plugin extends the build definition.
Mostly this means adding and overriding settings.

\emph{build.sbt} defines the build definition.
There can be several projects or subprojects as sbt doc calls it.

Here an example for a single project in \emph{build.sbt}:
\begin{lstlisting}[language=scala]
scalaVersion := "2.12.8"

lazy val root = (project in file("."))
\end{lstlisting}
The project is called root and its source files are located in the files' directory.
Executing \code{sbt compile} should now compile the code.

The Stainless web page has a guide on how to integrate Stainless in an existing project.
The simplifies steps are:
\begin{itemize}
  \item Install an external solver.
  \item Add Stainless sbt plugin to \emph{plugins.sbt}
  \item Enable the plugin in \emph{build.sbt} for the project.
\end{itemize}
After this setup, Stainless will report errors to the console, when running \code{sbt compile}.

\subsection{Command Line Tool}
There are two ways to use the command line tool.

Either download a prebuilt JAR file from efpl-lara/stainless GitHub repository or built a binary from source.
Prebuild versions are released by Stainless.
The latest was released on January 14, when there was no support for Scala 2.12.
The 'Bump Scala to 2.12.8' branch was merged on March 4.

If latest features are needed, like support for Scala 2.12, the build from source is required.
Here a short installation description.
Full description can be found on the Stainless documentation pages.
\begin{itemize}
  \item Install sbt.
  \item Check out GitHub repository.
  \item Run \code{sbt universal:stage} inside the project.
\end{itemize}
This generates \emph{frontends/scalac/target/universal/stage/bin/stainless-scalac}.

To check the source code with one of those either \code{java -jar downloaded.jar source.scala} or \code{stainless-scalac source.scala} must be invoked.
The file \emph{source.scala} is the file to be checked.

As compiling without a build tool, this command will become really complex for bigger projects.
All dependencies must be on the classpath and all source files appended.
Those are added with \code{-classpath Dep1.jar:Dep2.jar:...:DepN.jar src1.scala src2.scala ... srcM.scala}.

\section{Scala compatibility (Pure Scala, imperative features, dedicated BigInt, Generics...)}

To be verified the Scala code extended with Stainless annotations is passed to the framework as input.
The source code should be written in so called Pure Scala, a functional subset of Scala, so that Stainless can perform the verification.
Additionally the framework supports some imperative features. We will see some of this restrictions we have detected during this work in the next chapter.

\subsection{Functional Pure Scala}
The following functional elements are a part of Pure Scala:
\begin{itemize}
  \item \textbf{Algebraic Data Types:} abstract class, case class, case object. 
  The root of ADT is an abstarct class, unless only one case class or case object is defined.
  An abstract class cannot define fields and constructor arguments. 
  Case class and case object can extend an abstract class.
  An example of the ADT definition:
  \begin{lstlisting}[language=Scala]
    abstract class MyList
    case object MyEmpty extends MyList
    case class MyCons(elem: BigInt, rest: MyList) extends MyList
  \end{lstlisting}
  \item \textbf{Objects} for grouping classes and functions.
  An example of object definition:
  \begin{lstlisting}[language=Scala]
    object Specs {
      def increment(a: BigInt): BigInt = {
        a + 1
      }
    case class Identifier(id: BigInt)
    }
  \end{lstlisting}
  \item \textbf{Booleans:} logical operators  \textit{\&\&}, \textit{||}, \textit{!}, relational operator \textit{==}, Stainless syntax for boolean implication \textit{==>}. 
  The short-circuit interpretation is used, when the second argument of a boolean expression is evaluated only when needed.  
  \item \textbf{Generics.} Only invariant type parameters are supported, what means if S is subtype of T then List[S] and List[T] do not have sub-typing relationship.
  Covariant and contravariant type parameters, such as List[+T] and List[-T], are not supported. 
  Furthermore, only simple hierarchie is aloowed, when subclass must define the same type parameters in the same order as a parent class.
  An example using Generics:
  \begin{lstlisting}[language=Scala]
    object Test {
      abstract class List[T]
      case class Cons[T](hd: T, tl: List[T]) extends List[T]
      case class Nil[T]() extends List[T]
      def contains[T](l: List[T], el: T) = { ... }
    }
  \end{lstlisting}
  \item \textbf{Methods} can be defined in an abstract class and implemented or overridden in case classes. 
  The call of superclass methods with the keyword \textit{super} is allowed. 
  The method parameters can have default values. 
  An example of method definition in case of inheritance:
  \begin{lstlisting}[language=Scala]
    object Test {
      sealed abstract class Base {
        def double(x: BigInt): BigInt = x * 2
      }

      case class Override() extends Base {
        override def double(x: BigInt): BigInt = {
          super.double(x + 1) + 42
        }
      }
    }
  \end{lstlisting}
  \item \textbf{Pattern matching.} 
  Simple nested pattern matching, matching on type only, pattern quards and custom pattern matching with \textit{unapply} method are supported.
  \item \textbf{Values}. 
  Only immutable variables are allowed. Thus, they must be defined with the keyword \textit{val} (and not with \textit{var}).
  \item \textbf{Inner functions.}
  \item \textbf{Anonymous functions.}
  \item \textbf{Anonymous classes} with an explicit parent. 
  An anonymous class should have the same number of public members as its parent.
  An example of anonymous class implementation:
  \begin{lstlisting}[language=Scala]
    abstract class Foo {
      def bar: Int
    }
    
    def makeFoo(x: Int): Foo = new Foo {
      def bar: Int = x
    }
  \end{lstlisting}
  \item \textbf{Local classes}. 
  The creation of local classes within a function are allowed. \cite{Stainless:pure_scala}
\end{itemize}
\subsection{Predefined types}
\subsection{Imperative features}